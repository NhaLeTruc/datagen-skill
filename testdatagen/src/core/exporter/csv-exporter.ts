import {
  TableData,
  SchemaDefinition,
  GenerationOptions,
  Exporter
} from '../../types';

export class CSVExporter implements Exporter {
  /**
   * Export table data as CSV
   */
  public export(
    tableData: TableData[],
    schema: SchemaDefinition,
    options: GenerationOptions
  ): string {
    const sections: string[] = [];

    sections.push('# Generated by @claude-code/testdatagen');
    sections.push(`# Timestamp: ${new Date().toISOString()}`);
    sections.push(`# Total records: ${this.getTotalRecords(tableData)}`);
    sections.push('');

    for (const data of tableData) {
      sections.push(`# Table: ${data.table}`);
      sections.push(this.exportTable(data));
      sections.push('');
    }

    return sections.join('\n');
  }

  /**
   * Export single table as CSV
   */
  private exportTable(data: TableData): string {
    if (data.records.length === 0) {
      return `# No records for table ${data.table}`;
    }

    const columns = Object.keys(data.records[0]);
    const lines: string[] = [];

    lines.push(this.escapeRow(columns));

    for (const record of data.records) {
      const values = columns.map(col => this.formatValue(record[col]));
      lines.push(this.escapeRow(values));
    }

    return lines.join('\n');
  }

  /**
   * Export as separate CSV files
   */
  public exportSeparateFiles(
    tableData: TableData[],
    schema: SchemaDefinition,
    options: GenerationOptions
  ): Map<string, string> {
    const files = new Map<string, string>();

    for (const data of tableData) {
      const lines: string[] = [];

      lines.push(`# Table: ${data.table}`);
      lines.push(`# Generated: ${new Date().toISOString()}`);
      lines.push(`# Records: ${data.records.length}`);
      lines.push('');
      lines.push(this.exportTable(data));

      const filename = `${data.table}.csv`;
      files.set(filename, lines.join('\n'));
    }

    return files;
  }

  /**
   * Format value for CSV
   */
  private formatValue(value: any): string {
    if (value === null || value === undefined) {
      return '';
    }

    if (typeof value === 'string') {
      return value;
    }

    if (typeof value === 'number') {
      return String(value);
    }

    if (typeof value === 'boolean') {
      return value ? 'true' : 'false';
    }

    if (value instanceof Date) {
      return value.toISOString();
    }

    if (typeof value === 'object') {
      return JSON.stringify(value);
    }

    return String(value);
  }

  /**
   * Escape and quote CSV row
   */
  private escapeRow(values: string[]): string {
    const escaped = values.map(v => this.escapeCSV(v));
    return escaped.join(',');
  }

  /**
   * Escape CSV value
   */
  private escapeCSV(value: string): string {
    if (!value) {
      return '""';
    }

    const needsQuoting = value.includes(',') || value.includes('"') || value.includes('\n') || value.includes('\r');

    if (!needsQuoting) {
      return value;
    }

    const escaped = value.replace(/"/g, '""');
    return `"${escaped}"`;
  }

  /**
   * Export with custom delimiter
   */
  public exportWithDelimiter(
    tableData: TableData[],
    schema: SchemaDefinition,
    options: GenerationOptions,
    delimiter: string = ','
  ): string {
    const sections: string[] = [];

    for (const data of tableData) {
      if (data.records.length === 0) continue;

      const columns = Object.keys(data.records[0]);
      sections.push(columns.join(delimiter));

      for (const record of data.records) {
        const values = columns.map(col => this.formatValue(record[col]));
        sections.push(values.join(delimiter));
      }

      sections.push('');
    }

    return sections.join('\n');
  }

  /**
   * Export with headers
   */
  public exportWithHeaders(
    tableData: TableData[],
    schema: SchemaDefinition,
    options: GenerationOptions,
    includeTableName: boolean = true
  ): string {
    const sections: string[] = [];

    for (const data of tableData) {
      if (data.records.length === 0) continue;

      if (includeTableName) {
        sections.push(`Table: ${data.table}`);
      }

      sections.push(this.exportTable(data));
      sections.push('');
    }

    return sections.join('\n');
  }

  /**
   * Get total record count
   */
  private getTotalRecords(tableData: TableData[]): number {
    return tableData.reduce((sum, data) => sum + data.records.length, 0);
  }
}
