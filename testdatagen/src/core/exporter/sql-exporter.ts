import {
  TableData,
  SchemaDefinition,
  GenerationOptions,
  GeneratedRecord,
  Exporter
} from '../../types';

export class SQLExporter implements Exporter {
  /**
   * Export table data as SQL INSERT statements
   */
  public export(
    tableData: TableData[],
    schema: SchemaDefinition,
    options: GenerationOptions
  ): string {
    const lines: string[] = [];

    lines.push('-- Generated by @claude-code/testdatagen');
    lines.push(`-- Timestamp: ${new Date().toISOString()}`);
    lines.push(`-- Record count: ${this.getTotalRecords(tableData)}`);
    lines.push('');

    for (const data of tableData) {
      const table = schema.tables.find(t => t.name === data.table);
      if (!table) continue;

      lines.push(`-- Table: ${data.table}`);
      lines.push(`-- Records: ${data.records.length}`);
      lines.push('');

      if (data.records.length === 0) {
        lines.push(`-- No records generated for ${data.table}`);
        lines.push('');
        continue;
      }

      const insertStatements = this.generateInsertStatements(data);
      lines.push(...insertStatements);
      lines.push('');
    }

    return lines.join('\n');
  }

  /**
   * Generate INSERT statements for table data
   */
  private generateInsertStatements(data: TableData): string[] {
    const statements: string[] = [];

    if (data.records.length === 0) {
      return statements;
    }

    const columns = Object.keys(data.records[0]);
    const columnList = columns.map(c => this.escapeIdentifier(c)).join(', ');

    const batchSize = 100;
    for (let i = 0; i < data.records.length; i += batchSize) {
      const batch = data.records.slice(i, i + batchSize);
      const values = batch.map(record => this.generateValueList(record, columns));

      const statement = `INSERT INTO ${this.escapeIdentifier(data.table)} (${columnList}) VALUES\n${values.join(',\n')};`;
      statements.push(statement);
    }

    return statements;
  }

  /**
   * Generate value list for a record
   */
  private generateValueList(record: GeneratedRecord, columns: string[]): string {
    const values = columns.map(col => this.formatValue(record[col]));
    return `  (${values.join(', ')})`;
  }

  /**
   * Format value for SQL
   */
  private formatValue(value: any): string {
    if (value === null || value === undefined) {
      return 'NULL';
    }

    if (typeof value === 'string') {
      return this.escapeString(value);
    }

    if (typeof value === 'number') {
      return String(value);
    }

    if (typeof value === 'boolean') {
      return value ? 'TRUE' : 'FALSE';
    }

    if (value instanceof Date) {
      return this.escapeString(value.toISOString());
    }

    if (typeof value === 'object') {
      return this.escapeString(JSON.stringify(value));
    }

    return this.escapeString(String(value));
  }

  /**
   * Escape SQL string
   */
  private escapeString(str: string): string {
    return `'${str.replace(/'/g, "''")}'`;
  }

  /**
   * Escape SQL identifier
   */
  private escapeIdentifier(identifier: string): string {
    return `"${identifier.replace(/"/g, '""')}"`;
  }

  /**
   * Get total record count
   */
  private getTotalRecords(tableData: TableData[]): number {
    return tableData.reduce((sum, data) => sum + data.records.length, 0);
  }

  /**
   * Export as individual table files (returns map of filename -> content)
   */
  public exportSeparateFiles(
    tableData: TableData[],
    schema: SchemaDefinition,
    options: GenerationOptions
  ): Map<string, string> {
    const files = new Map<string, string>();

    for (const data of tableData) {
      const lines: string[] = [];

      lines.push('-- Generated by @claude-code/testdatagen');
      lines.push(`-- Table: ${data.table}`);
      lines.push(`-- Timestamp: ${new Date().toISOString()}`);
      lines.push(`-- Records: ${data.records.length}`);
      lines.push('');

      if (data.records.length > 0) {
        const insertStatements = this.generateInsertStatements(data);
        lines.push(...insertStatements);
      }

      const filename = `${data.table}.sql`;
      files.set(filename, lines.join('\n'));
    }

    return files;
  }

  /**
   * Export with DELETE statements (for idempotent inserts)
   */
  public exportWithDelete(
    tableData: TableData[],
    schema: SchemaDefinition,
    options: GenerationOptions
  ): string {
    const lines: string[] = [];

    lines.push('-- Generated by @claude-code/testdatagen');
    lines.push(`-- Timestamp: ${new Date().toISOString()}`);
    lines.push('-- Includes DELETE statements for idempotent execution');
    lines.push('');

    lines.push('-- Disable foreign key checks');
    lines.push('SET FOREIGN_KEY_CHECKS = 0;');
    lines.push('');

    const reversedOrder = [...tableData].reverse();
    for (const data of reversedOrder) {
      lines.push(`DELETE FROM ${this.escapeIdentifier(data.table)};`);
    }
    lines.push('');

    for (const data of tableData) {
      const table = schema.tables.find(t => t.name === data.table);
      if (!table || data.records.length === 0) continue;

      lines.push(`-- Table: ${data.table}`);
      const insertStatements = this.generateInsertStatements(data);
      lines.push(...insertStatements);
      lines.push('');
    }

    lines.push('-- Re-enable foreign key checks');
    lines.push('SET FOREIGN_KEY_CHECKS = 1;');
    lines.push('');

    return lines.join('\n');
  }

  /**
   * Export with transaction wrapper
   */
  public exportWithTransaction(
    tableData: TableData[],
    schema: SchemaDefinition,
    options: GenerationOptions
  ): string {
    const lines: string[] = [];

    lines.push('-- Generated by @claude-code/testdatagen');
    lines.push(`-- Timestamp: ${new Date().toISOString()}`);
    lines.push('-- Wrapped in transaction');
    lines.push('');

    lines.push('BEGIN;');
    lines.push('');

    const content = this.export(tableData, schema, options);
    const contentLines = content.split('\n').slice(4);
    lines.push(...contentLines);

    lines.push('');
    lines.push('COMMIT;');

    return lines.join('\n');
  }
}
