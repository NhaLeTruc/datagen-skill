import { SQLParser } from '../../src/core/parser/sql-parser';
import { GenerationEngine } from '../../src/core/generator/engine';
import { ConstraintValidator } from '../../src/core/validator/constraint-validator';
import { SQLExporter } from '../../src/core/exporter/sql-exporter';
import { GenerationOptions } from '../../src/types';

describe('Integration Test: Single Table Generation', () => {
  describe('Basic Users Table', () => {
    it('should generate valid data for simple users table', async () => {
      const sql = `
        CREATE TABLE users (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          username VARCHAR(50) NOT NULL UNIQUE,
          email VARCHAR(255) NOT NULL UNIQUE,
          first_name VARCHAR(100) NOT NULL,
          last_name VARCHAR(100) NOT NULL,
          age INTEGER,
          created_at TIMESTAMP NOT NULL,
          is_active BOOLEAN DEFAULT TRUE,
          CHECK (age >= 18 AND age <= 120)
        );
      `;

      const parser = new SQLParser();
      const schema = parser.parseSchema(sql);

      expect(schema.tables).toHaveLength(1);
      expect(schema.tables[0].name).toBe('users');
      expect(schema.tables[0].columns.length).toBeGreaterThan(0);

      const options: GenerationOptions = {
        count: 50,
        seed: 12345,
        locale: 'us',
        format: 'sql',
        validate: true
      };

      const engine = new GenerationEngine();
      const tableData = await engine.generate(schema, options);

      expect(tableData).toHaveLength(1);
      expect(tableData[0].records).toHaveLength(50);

      const validator = new ConstraintValidator();
      const validationResults = validator.validateAll(schema, tableData);

      expect(validationResults).toHaveLength(1);
      expect(validationResults[0].valid).toBe(true);
      expect(validationResults[0].errors).toHaveLength(0);

      const summary = validator.getValidationSummary(validationResults);
      expect(summary.validTables).toBe(1);
      expect(summary.invalidTables).toBe(0);
      expect(summary.totalErrors).toBe(0);
    });

    it('should generate unique usernames and emails', async () => {
      const sql = `
        CREATE TABLE users (
          id INTEGER PRIMARY KEY,
          username VARCHAR(50) UNIQUE,
          email VARCHAR(255) UNIQUE
        );
      `;

      const parser = new SQLParser();
      const schema = parser.parseSchema(sql);

      const options: GenerationOptions = {
        count: 100,
        seed: 42,
        format: 'sql'
      };

      const engine = new GenerationEngine();
      const tableData = await engine.generate(schema, options);

      const usernames = new Set();
      const emails = new Set();

      for (const record of tableData[0].records) {
        usernames.add(record.username);
        emails.add(record.email);
      }

      expect(usernames.size).toBe(100);
      expect(emails.size).toBe(100);
    });

    it('should respect NOT NULL constraints', async () => {
      const sql = `
        CREATE TABLE users (
          id INTEGER PRIMARY KEY,
          name VARCHAR(100) NOT NULL,
          email VARCHAR(255) NOT NULL
        );
      `;

      const parser = new SQLParser();
      const schema = parser.parseSchema(sql);

      const options: GenerationOptions = {
        count: 50,
        format: 'sql'
      };

      const engine = new GenerationEngine();
      const tableData = await engine.generate(schema, options);

      for (const record of tableData[0].records) {
        expect(record.name).not.toBeNull();
        expect(record.name).not.toBeUndefined();
        expect(record.email).not.toBeNull();
        expect(record.email).not.toBeUndefined();
      }
    });

    it('should export valid SQL', async () => {
      const sql = `
        CREATE TABLE products (
          id INTEGER PRIMARY KEY,
          name VARCHAR(255) NOT NULL,
          price DECIMAL(10, 2) NOT NULL,
          stock INTEGER DEFAULT 0
        );
      `;

      const parser = new SQLParser();
      const schema = parser.parseSchema(sql);

      const options: GenerationOptions = {
        count: 10,
        format: 'sql'
      };

      const engine = new GenerationEngine();
      const tableData = await engine.generate(schema, options);

      const exporter = new SQLExporter();
      const output = exporter.export(tableData, schema, options);

      expect(output).toContain('INSERT INTO');
      expect(output).toContain('products');
      expect(output).toContain('Generated by @claude-code/testdatagen');

      const insertStatements = output.match(/INSERT INTO/g);
      expect(insertStatements).not.toBeNull();
    });
  });

  describe('Multi-column Constraints', () => {
    it('should handle composite primary keys', async () => {
      const sql = `
        CREATE TABLE user_roles (
          user_id INTEGER,
          role_id INTEGER,
          assigned_at TIMESTAMP,
          PRIMARY KEY (user_id, role_id)
        );
      `;

      const parser = new SQLParser();
      const schema = parser.parseSchema(sql);

      const options: GenerationOptions = {
        count: 20,
        format: 'sql'
      };

      const engine = new GenerationEngine();
      const tableData = await engine.generate(schema, options);

      const validator = new ConstraintValidator();
      const validationResults = validator.validateAll(schema, tableData);

      expect(validationResults[0].valid).toBe(true);

      const compositeKeys = new Set();
      for (const record of tableData[0].records) {
        const key = `${record.user_id}-${record.role_id}`;
        expect(compositeKeys.has(key)).toBe(false);
        compositeKeys.add(key);
      }
    });

    it('should handle composite unique constraints', async () => {
      const sql = `
        CREATE TABLE user_permissions (
          id INTEGER PRIMARY KEY,
          user_id INTEGER,
          resource VARCHAR(100),
          action VARCHAR(50),
          UNIQUE (user_id, resource, action)
        );
      `;

      const parser = new SQLParser();
      const schema = parser.parseSchema(sql);

      const options: GenerationOptions = {
        count: 30,
        seed: 999,
        format: 'sql'
      };

      const engine = new GenerationEngine();
      const tableData = await engine.generate(schema, options);

      const validator = new ConstraintValidator();
      const validationResults = validator.validateAll(schema, tableData);

      expect(validationResults[0].valid).toBe(true);
    });
  });

  describe('Data Type Generation', () => {
    it('should generate appropriate data for various types', async () => {
      const sql = `
        CREATE TABLE test_types (
          id INTEGER PRIMARY KEY,
          int_col INTEGER,
          varchar_col VARCHAR(50),
          text_col TEXT,
          decimal_col DECIMAL(10, 2),
          date_col DATE,
          datetime_col DATETIME,
          bool_col BOOLEAN
        );
      `;

      const parser = new SQLParser();
      const schema = parser.parseSchema(sql);

      const options: GenerationOptions = {
        count: 10,
        format: 'sql'
      };

      const engine = new GenerationEngine();
      const tableData = await engine.generate(schema, options);

      const record = tableData[0].records[0];

      expect(typeof record.int_col).toBe('number');
      expect(Number.isInteger(record.int_col)).toBe(true);
      expect(typeof record.varchar_col).toBe('string');
      expect(record.varchar_col.length).toBeLessThanOrEqual(50);
      expect(typeof record.text_col).toBe('string');
      expect(typeof record.decimal_col).toBe('number');
      expect(typeof record.bool_col).toBe('boolean');
    });
  });

  describe('Reproducibility with Seed', () => {
    it('should generate same data with same seed', async () => {
      const sql = `
        CREATE TABLE users (
          id INTEGER PRIMARY KEY,
          name VARCHAR(100)
        );
      `;

      const parser = new SQLParser();
      const schema = parser.parseSchema(sql);

      const options1: GenerationOptions = {
        count: 10,
        seed: 12345,
        format: 'sql'
      };

      const options2: GenerationOptions = {
        count: 10,
        seed: 12345,
        format: 'sql'
      };

      const engine1 = new GenerationEngine();
      const tableData1 = await engine1.generate(schema, options1);

      const engine2 = new GenerationEngine();
      const tableData2 = await engine2.generate(schema, options2);

      expect(tableData1[0].records.length).toBe(tableData2[0].records.length);

      for (let i = 0; i < tableData1[0].records.length; i++) {
        expect(tableData1[0].records[i].id).toBe(tableData2[0].records[i].id);
      }
    });
  });

  describe('End-to-End Workflow', () => {
    it('should complete full workflow: parse → generate → validate → export', async () => {
      const sql = `
        CREATE TABLE customers (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          customer_code VARCHAR(20) NOT NULL UNIQUE,
          company_name VARCHAR(255) NOT NULL,
          email VARCHAR(255) NOT NULL UNIQUE,
          phone VARCHAR(20),
          country VARCHAR(100),
          created_at TIMESTAMP NOT NULL,
          is_active BOOLEAN DEFAULT TRUE
        );
      `;

      const parser = new SQLParser();
      const schema = parser.parseSchema(sql);
      expect(schema.tables).toHaveLength(1);

      const options: GenerationOptions = {
        count: 25,
        seed: 42,
        locale: 'us',
        format: 'sql',
        validate: true
      };

      const engine = new GenerationEngine();
      const tableData = await engine.generate(schema, options);
      expect(tableData).toHaveLength(1);
      expect(tableData[0].records).toHaveLength(25);

      const validator = new ConstraintValidator();
      const validationResults = validator.validateAll(schema, tableData);
      expect(validationResults[0].valid).toBe(true);

      const exporter = new SQLExporter();
      const sqlOutput = exporter.export(tableData, schema, options);
      expect(sqlOutput).toContain('INSERT INTO');
      expect(sqlOutput).toContain('customers');

      const files = exporter.exportSeparateFiles(tableData, schema, options);
      expect(files.has('customers.sql')).toBe(true);

      const transactionOutput = exporter.exportWithTransaction(tableData, schema, options);
      expect(transactionOutput).toContain('BEGIN;');
      expect(transactionOutput).toContain('COMMIT;');
    });
  });
});
